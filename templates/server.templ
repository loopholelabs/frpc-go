{{define "server"}}
type Server struct {
    *frisbee.Server
}

func NewServer({{ GetServerFields .services }}, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
        var s *Server
        table := make(frisbee.HandlerTable)
        {{template "serverhandlers" .services -}}
        var fsrv *frisbee.Server
        var err error
        if tlsConfig != nil {
            fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
            if err != nil {
                return nil, err
            }
        } else {
            fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
            if err != nil {
                return nil, err
            }
        }

        s, err = &Server{
            Server: fsrv,
        }, nil
        return s, err
    }
{{ end -}}

{{define "serverhandlers"}}
    {{ $counter := Counter 9 -}}
    {{ range $i, $v := (MakeIterable .Len) -}}
        {{ $service := $.Get $i -}}
        {{ range $i, $v := (MakeIterable $service.Methods.Len) -}}
            {{ $method := $service.Methods.Get $i -}}
            {{ $count := call $counter -}}
            table[{{ $count }}] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
                req := New{{ CamelCase $method.Input.FullName  }}()
                err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
                if err == nil {
                    if req.ignore {
                        {{ FirstLowerCaseName $service.Name }}.{{ CamelCaseName $method.Name }}(ctx, req)
                        return
                    }
                    var res *{{ CamelCase $method.Output.FullName }}
                    outgoing = incoming
                    outgoing.Content.Reset()
                    res, err = {{ FirstLowerCase (CamelCaseName $service.Name) }}.{{ CamelCaseName $method.Name }}(ctx, req)
                    if err != nil {
                        if _, ok := err.(CloseError); ok {
                            action = frisbee.CLOSE
                        }
                        res.Error(outgoing.Content, err)
                    } else {
                        res.Encode(outgoing.Content)
                    }
                    outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
                }
                return
            }
        {{end -}}
    {{end -}}
{{end}}