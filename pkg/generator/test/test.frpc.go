// Code generated by fRPC Go v0.7.1, DO NOT EDIT.
// source: test.proto

package test

import (
	"errors"
	"github.com/loopholelabs/polyglot-go"
	"net"

	"context"
	"crypto/tls"
	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/rs/zerolog"

	"sync"

	"go.uber.org/atomic"
	"io"
)

var (
	NilDecode = errors.New("cannot decode into a nil root struct")
)

type Test uint32

const (
	Potato = Test(0)
	Monkey = Test(1)
)

type RequestCorpus uint32

const (
	RequestUNIVERSAL = RequestCorpus(0)
	RequestWEB       = RequestCorpus(1)
	RequestIMAGES    = RequestCorpus(2)
	RequestLOCAL     = RequestCorpus(3)
	RequestNEWS      = RequestCorpus(4)
	RequestPRODUCTS  = RequestCorpus(5)
	RequestVIDEO     = RequestCorpus(6)
)

type Request struct {
	error error
	flags uint8

	Message string
	Corpus  RequestCorpus
}

func NewRequest() *Request {
	return &Request{}
}

func (x *Request) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Request) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Message).Uint32(uint32(x.Corpus))
	}
}

func (x *Request) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Request) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Message, err = d.String()
	if err != nil {
		return err
	}
	var CorpusTemp uint32
	CorpusTemp, err = d.Uint32()
	x.Corpus = RequestCorpus(CorpusTemp)
	if err != nil {
		return err
	}
	return nil
}

type Response struct {
	error error
	flags uint8

	Message string
	Test    *Data
}

func NewResponse() *Response {
	return &Response{
		Test: NewData(),
	}
}

func (x *Response) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Response) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Message)
		x.Test.Encode(b)
	}
}

func (x *Response) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Response) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Message, err = d.String()
	if err != nil {
		return err
	}
	if x.Test == nil {
		x.Test = NewData()
	}
	err = x.Test.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type Data struct {
	error error
	flags uint8

	Message string
	Checker Test
}

func NewData() *Data {
	return &Data{}
}

func (x *Data) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Data) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Message).Uint32(uint32(x.Checker))
	}
}

func (x *Data) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Data) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Message, err = d.String()
	if err != nil {
		return err
	}
	var CheckerTemp uint32
	CheckerTemp, err = d.Uint32()
	x.Checker = Test(CheckerTemp)
	if err != nil {
		return err
	}
	return nil
}

type MyMessage1EnumAllowingAlias uint32

const (
	MyMessage1UNKNOWN = MyMessage1EnumAllowingAlias(0)
	MyMessage1STARTED = MyMessage1EnumAllowingAlias(1)
	MyMessage1RUNNING = MyMessage1EnumAllowingAlias(2)
)

type MyMessage1 struct {
	error error
	flags uint8
}

func NewMyMessage1() *MyMessage1 {
	return &MyMessage1{}
}

func (x *MyMessage1) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *MyMessage1) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *MyMessage1) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *MyMessage1) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type MyMessage2EnumNotAllowingAlias uint32

const (
	MyMessage2UNKNOWN = MyMessage2EnumNotAllowingAlias(0)
	MyMessage2STARTED = MyMessage2EnumNotAllowingAlias(1)
)

type MyMessage2 struct {
	error error
	flags uint8
}

func NewMyMessage2() *MyMessage2 {
	return &MyMessage2{}
}

func (x *MyMessage2) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *MyMessage2) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *MyMessage2) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *MyMessage2) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type SearchResponseResult struct {
	error error
	flags uint8

	Url      string
	Title    string
	Snippets []string
}

func NewSearchResponseResult() *SearchResponseResult {
	return &SearchResponseResult{}
}

func (x *SearchResponseResult) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *SearchResponseResult) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Url).String(x.Title)
		polyglot.Encoder(b).Slice(uint32(len(x.Snippets)), polyglot.StringKind)
		for _, v := range x.Snippets {
			polyglot.Encoder(b).String(v)
		}
	}
}

func (x *SearchResponseResult) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *SearchResponseResult) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Url, err = d.String()
	if err != nil {
		return err
	}
	x.Title, err = d.String()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.StringKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Snippets)) != sliceSize {
		x.Snippets = make([]string, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.Snippets[i], err = d.String()
		if err != nil {
			return err
		}
	}
	return nil
}

type SearchResponse struct {
	error error
	flags uint8

	Results   []*SearchResponseResult
	Results2  []*SearchResponseResult
	Snippets  []string
	Snippets2 []string
}

func NewSearchResponse() *SearchResponse {
	return &SearchResponse{}
}

func (x *SearchResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *SearchResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		polyglot.Encoder(b).Slice(uint32(len(x.Results)), polyglot.AnyKind)
		for _, v := range x.Results {
			v.Encode(b)
		}
		polyglot.Encoder(b).Slice(uint32(len(x.Results2)), polyglot.AnyKind)
		for _, v := range x.Results2 {
			v.Encode(b)
		}
		polyglot.Encoder(b).Slice(uint32(len(x.Snippets)), polyglot.StringKind)
		for _, v := range x.Snippets {
			polyglot.Encoder(b).String(v)
		}
		polyglot.Encoder(b).Slice(uint32(len(x.Snippets2)), polyglot.StringKind)
		for _, v := range x.Snippets2 {
			polyglot.Encoder(b).String(v)
		}
	}
}

func (x *SearchResponse) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *SearchResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Results)) != sliceSize {
		x.Results = make([]*SearchResponseResult, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.Results[i] == nil {
			x.Results[i] = NewSearchResponseResult()
		}
		err = x.Results[i].decode(d)
		if err != nil {
			return err
		}
	}
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Results2)) != sliceSize {
		x.Results2 = make([]*SearchResponseResult, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.Results2[i] == nil {
			x.Results2[i] = NewSearchResponseResult()
		}
		err = x.Results2[i].decode(d)
		if err != nil {
			return err
		}
	}
	sliceSize, err = d.Slice(polyglot.StringKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Snippets)) != sliceSize {
		x.Snippets = make([]string, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.Snippets[i], err = d.String()
		if err != nil {
			return err
		}
	}
	sliceSize, err = d.Slice(polyglot.StringKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Snippets2)) != sliceSize {
		x.Snippets2 = make([]string, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.Snippets2[i], err = d.String()
		if err != nil {
			return err
		}
	}
	return nil
}

type Resulting struct {
	error error
	flags uint8

	Url      string
	Title    string
	Snippets []string
}

func NewResulting() *Resulting {
	return &Resulting{}
}

func (x *Resulting) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Resulting) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Url).String(x.Title)
		polyglot.Encoder(b).Slice(uint32(len(x.Snippets)), polyglot.StringKind)
		for _, v := range x.Snippets {
			polyglot.Encoder(b).String(v)
		}
	}
}

func (x *Resulting) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Resulting) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Url, err = d.String()
	if err != nil {
		return err
	}
	x.Title, err = d.String()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.StringKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Snippets)) != sliceSize {
		x.Snippets = make([]string, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.Snippets[i], err = d.String()
		if err != nil {
			return err
		}
	}
	return nil
}

type SomeOtherMessage struct {
	error error
	flags uint8

	Result *SearchResponseResult
}

func NewSomeOtherMessage() *SomeOtherMessage {
	return &SomeOtherMessage{
		Result: NewSearchResponseResult(),
	}
}

func (x *SomeOtherMessage) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *SomeOtherMessage) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		x.Result.Encode(b)
	}
}

func (x *SomeOtherMessage) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *SomeOtherMessage) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	if x.Result == nil {
		x.Result = NewSearchResponseResult()
	}
	err = x.Result.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type OuterMiddleAAInner struct {
	error error
	flags uint8

	Ival  int64
	Booly bool
}

func NewOuterMiddleAAInner() *OuterMiddleAAInner {
	return &OuterMiddleAAInner{}
}

func (x *OuterMiddleAAInner) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *OuterMiddleAAInner) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Int64(x.Ival).Bool(x.Booly)
	}
}

func (x *OuterMiddleAAInner) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *OuterMiddleAAInner) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ival, err = d.Int64()
	if err != nil {
		return err
	}
	x.Booly, err = d.Bool()
	if err != nil {
		return err
	}
	return nil
}

type OuterMiddleAA struct {
	error error
	flags uint8

	Inner *OuterMiddleAAInner
}

func NewOuterMiddleAA() *OuterMiddleAA {
	return &OuterMiddleAA{
		Inner: NewOuterMiddleAAInner(),
	}
}

func (x *OuterMiddleAA) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *OuterMiddleAA) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		x.Inner.Encode(b)
	}
}

func (x *OuterMiddleAA) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *OuterMiddleAA) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	if x.Inner == nil {
		x.Inner = NewOuterMiddleAAInner()
	}
	err = x.Inner.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type OuterMiddleBBInner struct {
	error error
	flags uint8

	Ival  int32
	Booly bool
}

func NewOuterMiddleBBInner() *OuterMiddleBBInner {
	return &OuterMiddleBBInner{}
}

func (x *OuterMiddleBBInner) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *OuterMiddleBBInner) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Int32(x.Ival).Bool(x.Booly)
	}
}

func (x *OuterMiddleBBInner) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *OuterMiddleBBInner) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ival, err = d.Int32()
	if err != nil {
		return err
	}
	x.Booly, err = d.Bool()
	if err != nil {
		return err
	}
	return nil
}

type OuterMiddleBB struct {
	error error
	flags uint8

	Inner *OuterMiddleBBInner
}

func NewOuterMiddleBB() *OuterMiddleBB {
	return &OuterMiddleBB{
		Inner: NewOuterMiddleBBInner(),
	}
}

func (x *OuterMiddleBB) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *OuterMiddleBB) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		x.Inner.Encode(b)
	}
}

func (x *OuterMiddleBB) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *OuterMiddleBB) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	if x.Inner == nil {
		x.Inner = NewOuterMiddleBBInner()
	}
	err = x.Inner.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type Outer struct {
	error error
	flags uint8

	A *OuterMiddleAA
	B *OuterMiddleBB
}

func NewOuter() *Outer {
	return &Outer{
		A: NewOuterMiddleAA(),
		B: NewOuterMiddleBB(),
	}
}

func (x *Outer) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Outer) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		x.A.Encode(b)
		x.B.Encode(b)
	}
}

func (x *Outer) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Outer) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	if x.A == nil {
		x.A = NewOuterMiddleAA()
	}
	err = x.A.decode(d)
	if err != nil {
		return err
	}
	if x.B == nil {
		x.B = NewOuterMiddleBB()
	}
	err = x.B.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type SampleMessage struct {
	error error
	flags uint8

	Name   string
	Potato string
}

func NewSampleMessage() *SampleMessage {
	return &SampleMessage{}
}

func (x *SampleMessage) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *SampleMessage) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Name).String(x.Potato)
	}
}

func (x *SampleMessage) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *SampleMessage) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Name, err = d.String()
	if err != nil {
		return err
	}
	x.Potato, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type TestPotatoPricesMap map[string]Test

func NewTestPotatoPricesMap(size uint32) map[string]Test {
	return make(map[string]Test, size)
}

func (x TestPotatoPricesMap) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		polyglot.Encoder(b).Map(uint32(len(x)), polyglot.StringKind, polyglot.Uint32Kind)
		for k, v := range x {
			polyglot.Encoder(b).String(k)
			polyglot.Encoder(b).Uint32(uint32(v))
		}
	}
}

func (x TestPotatoPricesMap) decode(d *polyglot.Decoder, size uint32) error {
	if size == 0 {
		return nil
	}
	var k string
	var v Test
	var ValueTemp uint32
	var err error
	for i := uint32(0); i < size; i++ {
		k, err = d.String()
		if err != nil {
			return err
		}
		ValueTemp, err = d.Uint32()
		v = Test(ValueTemp)
		if err != nil {
			return err
		}
		x[k] = v
	}
	return nil
}

type TestPotato struct {
	error error
	flags uint8

	Prices TestPotatoPricesMap
}

func NewTestPotato() *TestPotato {
	return &TestPotato{}
}

func (x *TestPotato) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *TestPotato) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		x.Prices.Encode(b)
	}
}

func (x *TestPotato) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *TestPotato) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	if !d.Nil() {
		PricesSize, err := d.Map(polyglot.StringKind, polyglot.Uint32Kind)
		if err != nil {
			return err
		}
		x.Prices = NewTestPotatoPricesMap(PricesSize)
		err = x.Prices.decode(d, PricesSize)
		if err != nil {
			return err
		}
	}
	return nil
}

type StockPricesPricesMap map[string]float64

func NewStockPricesPricesMap(size uint32) map[string]float64 {
	return make(map[string]float64, size)
}

func (x StockPricesPricesMap) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		polyglot.Encoder(b).Map(uint32(len(x)), polyglot.StringKind, polyglot.Float64Kind)
		for k, v := range x {
			polyglot.Encoder(b).String(k)
			polyglot.Encoder(b).Float64(v)
		}
	}
}

func (x StockPricesPricesMap) decode(d *polyglot.Decoder, size uint32) error {
	if size == 0 {
		return nil
	}
	var k string
	var v float64
	var err error
	for i := uint32(0); i < size; i++ {
		k, err = d.String()
		if err != nil {
			return err
		}
		v, err = d.Float64()
		if err != nil {
			return err
		}
		x[k] = v
	}
	return nil
}

type StockPrices struct {
	error error
	flags uint8

	Prices StockPricesPricesMap
}

func NewStockPrices() *StockPrices {
	return &StockPrices{}
}

func (x *StockPrices) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *StockPrices) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		x.Prices.Encode(b)
	}
}

func (x *StockPrices) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *StockPrices) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	if !d.Nil() {
		PricesSize, err := d.Map(polyglot.StringKind, polyglot.Float64Kind)
		if err != nil {
			return err
		}
		x.Prices = NewStockPricesPricesMap(PricesSize)
		err = x.Prices.decode(d, PricesSize)
		if err != nil {
			return err
		}
	}
	return nil
}

type StockPricesWrapper struct {
	error error
	flags uint8

	SPrices []*StockPrices
}

func NewStockPricesWrapper() *StockPricesWrapper {
	return &StockPricesWrapper{}
}

func (x *StockPricesWrapper) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *StockPricesWrapper) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		polyglot.Encoder(b).Slice(uint32(len(x.SPrices)), polyglot.AnyKind)
		for _, v := range x.SPrices {
			v.Encode(b)
		}
	}
}

func (x *StockPricesWrapper) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *StockPricesWrapper) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.SPrices)) != sliceSize {
		x.SPrices = make([]*StockPrices, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.SPrices[i] == nil {
			x.SPrices[i] = NewStockPrices()
		}
		err = x.SPrices[i].decode(d)
		if err != nil {
			return err
		}
	}
	return nil
}

type StockPricesSuperWrapPricesMap map[string]*StockPricesWrapper

func NewStockPricesSuperWrapPricesMap(size uint32) map[string]*StockPricesWrapper {
	return make(map[string]*StockPricesWrapper, size)
}

func (x StockPricesSuperWrapPricesMap) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		polyglot.Encoder(b).Map(uint32(len(x)), polyglot.StringKind, polyglot.AnyKind)
		for k, v := range x {
			polyglot.Encoder(b).String(k)
			v.Encode(b)
		}
	}
}

func (x StockPricesSuperWrapPricesMap) decode(d *polyglot.Decoder, size uint32) error {
	if size == 0 {
		return nil
	}
	var k string
	var v *StockPricesWrapper
	var err error
	for i := uint32(0); i < size; i++ {
		k, err = d.String()
		if err != nil {
			return err
		}
		v = NewStockPricesWrapper()
		err = v.decode(d)
		if err != nil {
			return err
		}
		x[k] = v
	}
	return nil
}

type StockPricesSuperWrap struct {
	error error
	flags uint8

	Prices StockPricesSuperWrapPricesMap
}

func NewStockPricesSuperWrap() *StockPricesSuperWrap {
	return &StockPricesSuperWrap{}
}

func (x *StockPricesSuperWrap) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *StockPricesSuperWrap) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		x.Prices.Encode(b)
	}
}

func (x *StockPricesSuperWrap) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *StockPricesSuperWrap) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	if !d.Nil() {
		PricesSize, err := d.Map(polyglot.StringKind, polyglot.AnyKind)
		if err != nil {
			return err
		}
		x.Prices = NewStockPricesSuperWrapPricesMap(PricesSize)
		err = x.Prices.decode(d, PricesSize)
		if err != nil {
			return err
		}
	}
	return nil
}

type EchoService interface {
	Echo(context.Context, *Request) (*Response, error)

	EchoStream(srv *EchoStreamServer) error
	Testy(context.Context, *SearchResponse) (*StockPricesWrapper, error)

	Search(req *SearchResponse, srv *SearchServer) error

	Upload(srv *UploadServer) error
}

const connectionContextKey int = 1000

func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

type RPCStreamOpen struct {
	operation uint16
}

func (x *RPCStreamOpen) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *RPCStreamOpen) Encode(b *polyglot.Buffer) {
	polyglot.Encoder(b).Uint16(x.operation)
}

func (x *RPCStreamOpen) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *RPCStreamOpen) decode(d *polyglot.Decoder) error {
	var err error
	x.operation, err = d.Uint16()
	return err
}

type Server struct {
	*frisbee.Server
	onClosed func(*frisbee.Async, error)
}

func NewServer(echoService EchoService, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
	var s *Server
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *Response
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = echoService.Echo(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewSearchResponse()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *StockPricesWrapper
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = echoService.Testy(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	var fsrv *frisbee.Server
	var err error
	if tlsConfig != nil {
		fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	fsrv.SetStreamHandler(func(conn *frisbee.Async, stream *frisbee.Stream) {
		p, err := stream.ReadPacket()
		if err != nil {
			return
		}
		open := &RPCStreamOpen{}
		err = open.Decode(*p.Content)
		if err != nil {
			stream.Close()
			return
		}
		switch open.operation {
		case 11:
			s.createEchoStreamServer(echoService, stream)
		case 13:
			s.createSearchServer(echoService, stream)
		case 14:
			s.createUploadServer(echoService, stream)
		}
	})

	fsrv.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, connectionContextKey, conn)
	}
	s, err = &Server{
		Server: fsrv,
	}, nil

	fsrv.SetOnClosed(func(async *frisbee.Async, err error) {
		if s.onClosed != nil {
			s.onClosed(async, err)
		}
	})
	return s, err
}

func (s *Server) SetOnClosed(f func(*frisbee.Async, error)) error {
	if f == nil {
		return frisbee.OnClosedNil
	}
	s.onClosed = f
	return nil
}

type EchoStreamServer struct {
	recv func() (*Request, error)
	send func(*Response) error

	stream *frisbee.Stream
	closed *atomic.Bool
}

func (s *Server) createEchoStreamServer(echoService EchoService, stream *frisbee.Stream) {
	srv := &EchoStreamServer{
		closed: atomic.NewBool(false),
		stream: stream,
	}

	srv.recv = func() (*Request, error) {
		p, err := srv.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewRequest()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}
	srv.send = func(m *Response) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return srv.stream.WritePacket(p)
	}

	go func() {
		err := echoService.EchoStream(srv)
		if err != nil {
			res := Response{error: err}
			res.flags = SetErrorFlag(res.flags, true)
			srv.CloseAndSend(&res)
		} else {
			srv.CloseSend()
		}
	}()
}

func (x *EchoStreamServer) Recv() (*Request, error) {
	return x.recv()
}

func (x *EchoStreamServer) close() {
	x.stream.Close()
}
func (x *EchoStreamServer) Send(m *Response) error {
	return x.send(m)
}
func (x *EchoStreamServer) CloseSend() error {
	return x.send(&Response{error: io.EOF})
}

func (x *EchoStreamServer) CloseAndSend(m *Response) error {
	err := x.send(m)
	if err != nil {
		return err
	}
	return x.CloseSend()
}

type SearchServer struct {
	recv func() (*SearchResponse, error)
	send func(*Response) error

	stream *frisbee.Stream
	closed *atomic.Bool
}

func (s *Server) createSearchServer(echoService EchoService, stream *frisbee.Stream) {
	srv := &SearchServer{
		closed: atomic.NewBool(false),
		stream: stream,
	}

	srv.send = func(m *Response) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return srv.stream.WritePacket(p)
	}

	incoming, err := stream.ReadPacket()
	if err != nil {
		return
	}
	req := NewSearchResponse()
	err = req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
	go func() {

		err := echoService.Search(req, srv)
		if err != nil {
			res := Response{error: err}
			res.flags = SetErrorFlag(res.flags, true)
			srv.CloseAndSend(&res)
		} else {
			srv.CloseSend()
		}
	}()
}

func (x *SearchServer) Send(m *Response) error {
	return x.send(m)
}
func (x *SearchServer) CloseSend() error {
	return x.send(&Response{error: io.EOF})
}

func (x *SearchServer) CloseAndSend(m *Response) error {
	err := x.send(m)
	if err != nil {
		return err
	}
	return x.CloseSend()
}

type UploadServer struct {
	recv func() (*Data, error)
	send func(*Response) error

	stream *frisbee.Stream
	closed *atomic.Bool
}

func (s *Server) createUploadServer(echoService EchoService, stream *frisbee.Stream) {
	srv := &UploadServer{
		closed: atomic.NewBool(false),
		stream: stream,
	}

	srv.recv = func() (*Data, error) {
		p, err := srv.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewData()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}
	srv.send = func(m *Response) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return srv.stream.WritePacket(p)
	}

	go func() {
		err := echoService.Upload(srv)
		if err != nil {
			res := Response{error: err}
			res.flags = SetErrorFlag(res.flags, true)
			srv.CloseAndSend(&res)
		} else {
			srv.CloseSend()
		}
	}()
}

func (x *UploadServer) Recv() (*Data, error) {
	return x.recv()
}

func (x *UploadServer) close() {
	x.stream.Close()
}
func (x *UploadServer) CloseSend() error {
	return x.send(&Response{error: io.EOF})
}

func (x *UploadServer) CloseAndSend(m *Response) error {
	err := x.send(m)
	if err != nil {
		return err
	}
	return x.CloseSend()
}

type subEchoServiceClient struct {
	client            *frisbee.Client
	nextEcho          uint16
	nextEchoMu        sync.RWMutex
	inflightEcho      map[uint16]chan *Response
	inflightEchoMu    sync.RWMutex
	nextTesty         uint16
	nextTestyMu       sync.RWMutex
	inflightTesty     map[uint16]chan *StockPricesWrapper
	inflightTestyMu   sync.RWMutex
	nextStreamingID   uint16
	nextStreamingIDMu sync.RWMutex
}
type Client struct {
	*frisbee.Client
	EchoService *subEchoServiceClient
}

func NewClient(tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.EchoService.inflightEchoMu.RLock()
		if ch, ok := c.EchoService.inflightEcho[incoming.Metadata.Id]; ok {
			c.EchoService.inflightEchoMu.RUnlock()
			res := NewResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.EchoService.inflightEchoMu.RUnlock()
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.EchoService.inflightTestyMu.RLock()
		if ch, ok := c.EchoService.inflightTesty[incoming.Metadata.Id]; ok {
			c.EchoService.inflightTestyMu.RUnlock()
			res := NewStockPricesWrapper()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.EchoService.inflightTestyMu.RUnlock()
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.EchoService = new(subEchoServiceClient)
	c.EchoService.client = c.Client
	c.EchoService.nextEchoMu.Lock()
	c.EchoService.nextEcho = 0
	c.EchoService.nextEchoMu.Unlock()
	c.EchoService.inflightEcho = make(map[uint16]chan *Response)
	c.EchoService.nextTestyMu.Lock()
	c.EchoService.nextTesty = 0
	c.EchoService.nextTestyMu.Unlock()
	c.EchoService.inflightTesty = make(map[uint16]chan *StockPricesWrapper)
	return c, nil
}

func (c *Client) Connect(addr string, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.Connect(addr, func(stream *frisbee.Stream) {})
}

func (c *Client) FromConn(conn net.Conn, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.FromConn(conn, func(stream *frisbee.Stream) {})
}

func (c *subEchoServiceClient) Echo(ctx context.Context, req *Request) (res *Response, err error) {
	ch := make(chan *Response, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextEchoMu.Lock()
	c.nextEcho += 1
	id := c.nextEcho
	c.nextEchoMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightEchoMu.Lock()
	c.inflightEcho[id] = ch
	c.inflightEchoMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightEchoMu.Lock()
	delete(c.inflightEcho, id)
	c.inflightEchoMu.Unlock()
	packet.Put(p)
	return
}

func (c *subEchoServiceClient) EchoStream(ctx context.Context, req *Request) (*EchoStreamClient, error) {
	p := packet.Get()

	c.nextStreamingIDMu.Lock()
	c.nextStreamingID += 1
	id := c.nextStreamingID
	c.nextStreamingIDMu.Unlock()

	open := &RPCStreamOpen{operation: 11}

	open.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))

	fStream := c.client.Stream(id)
	fStream.WritePacket(p)

	if req != nil {
		p2 := packet.Get()
		req.Encode(p2.Content)
		p2.Metadata.ContentLength = uint32(len(*p2.Content))
		fStream.WritePacket(p2)
	}

	stream := EchoStreamClient{
		context: ctx,
		stream:  fStream,
		closed:  atomic.NewBool(false),
	}

	stream.recv = func() (*Response, error) {
		p, err := stream.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewResponse()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}

	stream.close = func() {
		stream.stream.Close()
	}
	stream.send = func(m *Request) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return stream.stream.WritePacket(p)
	}
	return &stream, nil
}

type EchoStreamClient struct {
	context context.Context
	recv    func() (*Response, error)
	close   func()
	closed  *atomic.Bool

	stream *frisbee.Stream
	send   func(*Request) error
}

func (x *EchoStreamClient) Recv() (*Response, error) {
	return x.recv()
}
func (x *EchoStreamClient) Send(m *Request) error {
	return x.send(m)
}

func (x *EchoStreamClient) CloseSend() error {
	return x.send(&Request{error: io.EOF})
}

func (x *EchoStreamClient) CloseAndRecv() (*Response, error) {
	err := x.send(&Request{error: io.EOF})
	if err != nil {
		return nil, err
	}
	return x.recv()
}

func (c *subEchoServiceClient) Testy(ctx context.Context, req *SearchResponse) (res *StockPricesWrapper, err error) {
	ch := make(chan *StockPricesWrapper, 1)
	p := packet.Get()
	p.Metadata.Operation = 12

	c.nextTestyMu.Lock()
	c.nextTesty += 1
	id := c.nextTesty
	c.nextTestyMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightTestyMu.Lock()
	c.inflightTesty[id] = ch
	c.inflightTestyMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightTestyMu.Lock()
	delete(c.inflightTesty, id)
	c.inflightTestyMu.Unlock()
	packet.Put(p)
	return
}

func (c *subEchoServiceClient) Search(ctx context.Context, req *SearchResponse) (*SearchClient, error) {
	p := packet.Get()

	c.nextStreamingIDMu.Lock()
	c.nextStreamingID += 1
	id := c.nextStreamingID
	c.nextStreamingIDMu.Unlock()

	open := &RPCStreamOpen{operation: 13}

	open.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))

	fStream := c.client.Stream(id)
	fStream.WritePacket(p)

	if req != nil {
		p2 := packet.Get()
		req.Encode(p2.Content)
		p2.Metadata.ContentLength = uint32(len(*p2.Content))
		fStream.WritePacket(p2)
	}

	stream := SearchClient{
		context: ctx,
		stream:  fStream,
		closed:  atomic.NewBool(false),
	}

	stream.recv = func() (*Response, error) {
		p, err := stream.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewResponse()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}

	stream.close = func() {
		stream.stream.Close()
	}
	stream.send = func(m *SearchResponse) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return stream.stream.WritePacket(p)
	}
	return &stream, nil
}

type SearchClient struct {
	context context.Context
	recv    func() (*Response, error)
	close   func()
	closed  *atomic.Bool

	stream *frisbee.Stream
	send   func(*SearchResponse) error
}

func (x *SearchClient) Recv() (*Response, error) {
	return x.recv()
}

func (c *subEchoServiceClient) Upload(ctx context.Context, req *Data) (*UploadClient, error) {
	p := packet.Get()

	c.nextStreamingIDMu.Lock()
	c.nextStreamingID += 1
	id := c.nextStreamingID
	c.nextStreamingIDMu.Unlock()

	open := &RPCStreamOpen{operation: 14}

	open.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))

	fStream := c.client.Stream(id)
	fStream.WritePacket(p)

	if req != nil {
		p2 := packet.Get()
		req.Encode(p2.Content)
		p2.Metadata.ContentLength = uint32(len(*p2.Content))
		fStream.WritePacket(p2)
	}

	stream := UploadClient{
		context: ctx,
		stream:  fStream,
		closed:  atomic.NewBool(false),
	}

	stream.recv = func() (*Response, error) {
		p, err := stream.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewResponse()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}

	stream.close = func() {
		stream.stream.Close()
	}
	stream.send = func(m *Data) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return stream.stream.WritePacket(p)
	}
	return &stream, nil
}

type UploadClient struct {
	context context.Context
	recv    func() (*Response, error)
	close   func()
	closed  *atomic.Bool

	stream *frisbee.Stream
	send   func(*Data) error
}

func (x *UploadClient) Send(m *Data) error {
	return x.send(m)
}

func (x *UploadClient) CloseSend() error {
	return x.send(&Data{error: io.EOF})
}

func (x *UploadClient) CloseAndRecv() (*Response, error) {
	err := x.send(&Data{error: io.EOF})
	if err != nil {
		return nil, err
	}
	return x.recv()
}

type CloseError struct {
	err error
}

func NewCloseError(err error) CloseError {
	return CloseError{err: err}
}

func (e CloseError) Error() string {
	return e.err.Error()
}
